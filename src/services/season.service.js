const Models = require('../models');
const seasons = Models.gameSeason;
const userLeagues = Models.userLeagues;
const { Op, UniqueConstraintError } = require('sequelize');
const userService = require('./users.service');
const db = require('../database/database');
const { UserInputError } = require('../utils/classes');

module.exports = {
  async createSeason(data) {
    try {
      return await seasons.create(data, { raw: true });
    } catch {
      if (error instanceof UniqueConstraintError) {
        console.error('UniqueConstraintError: ', error.message);
        throw new UserInputError('Season already exists');
      }
      throw error;
    }
  },

  async createBulkseason(data) {
    return await seasons.bulkCreate(data);
  },
  async findseasons(gameId) {
    return await seasons.findOne({
      where: { seasonId: gameId }
    });
  },

  async findAllseasons(seasonId) {
    return await seasons.findAll({
      where: {
        seasonId: seasonId
      },
      attributes: ['id', 'seasonId', 'leagueId', 'startTime', 'endTime'],
      order: [['id', 'DESC']]
    });
  },

  async updateSeasons(data, id) {
    return await seasons.update(data, { where: { seasonId: id }, returning: true, raw: true });
  },

  async getSeasonCount() {
    return await seasons.findAll({
      attributes: ['id', 'seasonId', 'leagueId', 'startTime', 'endTime'],
      order: [['id', 'DESC']],
      limit: 1
    });
  },

  async getSingleSeasonDetails(seasonId) {
    return await seasons.findOne({
      where: { seasonId: seasonId }
    });
  },

  async deleteSeasonDetails(seasonId) {
    return await seasons.destroy({
      where: { seasonId: seasonId }
    });
  },
  async getCurrentSeason() {
    let currentTime = new Date();
    return await seasons.findOne({
      // attributes: ['id', 'seasonId', 'leagueId', 'startTime', 'endTime'],
      where: { startTime: { [Op.lte]: currentTime }, endTime: { [Op.gte]: currentTime } },
      // order: [['id', 'DESC']],
      raw: true
    });
  },

  async getCurrentSeasonForLeague(leagueId) {
    let currentTime = new Date().toUTCString();
    return await seasons.findOne({
      attributes: ['id', 'seasonId', 'leagueId', 'startTime', 'endTime'],
      where: { startTime: { [Op.lte]: currentTime }, endTime: { [Op.gte]: currentTime }, leagueId: leagueId }
      // order: [['id', 'DESC']],
      // limit: 1
    });
  },
  async getCurrentSeason() {
    let currentTime = new Date().toUTCString();
    return await seasons.findOne({
      where: { startTime: { [Op.lte]: currentTime }, endTime: { [Op.gte]: currentTime } },
      raw: true
    });
  },

  async getParticipatingUserslatest() {
    let today = new Date();
    today.setDate(today.getDate() - 1);

    try {
      let seasonList = await seasons.findAll({
        attributes: ['id', 'seasonId', 'leagueId', 'startTime', 'endTime'],
        where: { endTime: { [Op.lte]: today } }
      });
      let seasonListIds = seasonList.map((dt) => {
        return dt.seasonId;
      });

      let participatingUser = await userLeagues.findAll({
        attributes: ['id', 'userId', 'leagueId', 'seasonId'],
        where: { seasonId: { [Op.in]: seasonListIds } }
      });

      let participatingUserIds = participatingUser.map((dt) => {
        return dt.userId;
      });

      for (let i = 0; i < participatingUserIds.length; i++) {
        const element = participatingUserIds[i];
        await userService.updateUser(element, { isHaveMinFuel: false });
      }

      return 'FuelUpdated';
    } catch (error) {
      console.error(error);
    }
  },
  async getSeason() {
    const season = await seasons.findOne({ order: [['id', 'DESC']], raw: true });
    return season;
  },

  async getExistingSeason() {
    let currentTime = new Date().toUTCString();
    return await seasons.findOne({
      // attributes: ['id', 'seasonId', 'startTime', 'endTime'],
      attributes: {
        exclude: ['top_users', 'genesis_rewards_obj']
      },
      where: { startTime: { [Op.lte]: currentTime }, endTime: { [Op.gte]: currentTime } },
      raw: true
    });
  },

  async getRecentSeason() {
    return await seasons.findOne({
      raw: true,
      where: { endTime: { [Op.lte]: new Date() } },
      order: [['endTime', 'desc']]
    });
  },

  async getSeasonById(seasonId) {
    return await seasons.findOne({ where: { seasonId }, raw: true })
  },

  async getNextSeason() {
    let currentTime = new Date().toUTCString();
    return await seasons.findOne({ where: { startTime: { [Op.gt]: currentTime } }, order: [['startTime', 'ASC']], raw: true })
  },


  async getUserSeasonTreasureBoxes(userId, query) {
    // !! model associations wasnt working, table names are too long, even PGAdmin4 wasnt able run the query generated by sequelize, alias also didnt work

    let whereClause = `WHERE is_claimed = false AND claimed_at is null and src.user_id = ${userId}`;
    const [rows, { rowCount: count }] = await db.query(`
    SELECT src.id as id, rank, reward_Settings_id, src.user_id, src.wallet_address, is_claimed, src.transaction_hash, claimed_at, season_id, "rank",
      card_id, amount, srs.treasurebox_type_id, treasurebox_type_name, reward_contents_type_id, season_reward_contents_type_name
    FROM public.nftduel_season_reward_claims as src
    join nftduel_season_reward_settings as srs on srs.id = src.reward_settings_id
    join nftduel_season_reward_contents_type as srct on srct.season_reward_contents_type_id = srs.reward_contents_type_id
    join nftduel_season_reward_treasurebox_type srctt on srctt.treasurebox_type_id = srs.treasurebox_type_id
    -- join nftduel_cards as nc on srs.card_id = nc.card_id
    ${whereClause}
    -- AND src.wallet_address = lower('0xf11032f08b26e521590e4d4ee8aea31e2d57a6ff')
    ORDER BY src.id desc
    `);

    return { count, rows };
  }

};
